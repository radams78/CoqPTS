<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset="><link rel="stylesheet" href="style.css" type="text/css"><title>PTS2</title>
</head>

<body>

<h1>Library PTS2</h1>

<code>
<code class="keyword">Definition</code> <a name="liftfun"></a>liftfun (X Y : Set) (rho : X -&gt; Y) (x : option X) : option Y :=<br/>
&nbsp;&nbsp;match x with<br/>
&nbsp;&nbsp;| None =&gt; None<br/>
&nbsp;&nbsp;| Some x0 =&gt; Some (rho x0)<br/>
&nbsp;&nbsp;end.<br/>

<br/>
<code class="keyword">Implicit</code> Arguments liftfun [X Y].<br/>

<br/>
<code class="keyword">Fixpoint</code> <a name="fin"></a>fin (n : nat) {struct n} : Set :=<br/>
&nbsp;&nbsp;match n with<br/>
&nbsp;&nbsp;| O =&gt; Empty_set<br/>
&nbsp;&nbsp;| S m =&gt; option (fin m)<br/>
&nbsp;&nbsp;end.<br/>

<br/>
<code class="keyword">Definition</code> <a name="bot"></a>bot (n : nat) : fin (S n) := None.<br/>
<code class="keyword">Implicit</code> Arguments bot [n].<br/>
<code class="keyword">Definition</code> <a name="up"></a>up (n : nat) (x : fin n) : fin (S n) := Some x.<br/>
<code class="keyword">Implicit</code> Arguments up [n].<br/>

<br/>
<code class="keyword">Definition</code> <a name="Sfun"></a>Sfun (m n : nat) : (fin m -&gt; fin n) -&gt; fin (S m) -&gt; fin (S n)<br/>
&nbsp;&nbsp;:= liftfun (X:= fin m) (Y:= fin n).<br/>
<code class="keyword">Implicit</code> Arguments Sfun [m n].<br/>

<br/>
<code class="keyword">Parameter</code> <a name="sort"></a>sort : Set.<br/>

<br/>
<code class="keyword">Inductive</code> <a name="term"></a>term : nat -&gt; Set :=<br/>
&nbsp;&nbsp;<a name="var"></a>var :&gt; forall n : nat, fin n -&gt; term n |<br/>
&nbsp;&nbsp;<a name="srt"></a>srt : forall n : nat, sort -&gt; term n |<br/>
&nbsp;&nbsp;<a name="app"></a>app : forall n : nat, term n -&gt; term n -&gt; term n |<br/>
&nbsp;&nbsp;<a name="pi"></a>pi : forall n : nat, term n -&gt; term (S n) -&gt; term n |<br/>
&nbsp;&nbsp;<a name="lda"></a>lda : forall n : nat, term n -&gt; term (S n) -&gt; term n.<br/>
<code class="keyword">Implicit</code> Arguments var [n].<br/>
<code class="keyword">Implicit</code> Arguments srt [n].<br/>
<code class="keyword">Implicit</code> Arguments app [n].<br/>
<code class="keyword">Implicit</code> Arguments pi [n].<br/>
<code class="keyword">Implicit</code> Arguments lda [n].<br/>

<br/>
<code class="keyword">Definition</code> <a name="appleft"></a>appleft : forall (n : nat) (M : term n), term n.<br/>
&nbsp;&nbsp;intros.<br/>
&nbsp;&nbsp;case M.<br/>
&nbsp;&nbsp;exact var.<br/>
&nbsp;&nbsp;exact srt.<br/>
&nbsp;&nbsp;intros.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;exact t. <br/>
&nbsp;&nbsp;exact pi. <br/>
&nbsp;&nbsp;exact lda.<br/>
<code class="keyword">Defined</code>.<br/>

<br/>
<code class="keyword">Implicit</code> Arguments appleft [n].<br/>

<br/>
<code class="keyword">Definition</code> <a name="appright"></a>appright : forall (n : nat) (M : term n), term n.<br/>
&nbsp;&nbsp;intros.<br/>
&nbsp;&nbsp;case M.<br/>
&nbsp;&nbsp;exact var.<br/>
&nbsp;&nbsp;exact srt.<br/>
&nbsp;&nbsp;intros.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;exact t0.<br/>
&nbsp;&nbsp;exact pi.<br/>
&nbsp;&nbsp;exact lda.<br/>
<code class="keyword">Defined</code>.<br/>

<br/>
<code class="keyword">Implicit</code> Arguments appright [n].<br/>

<br/>
<code class="keyword">Definition</code> <a name="quantleft"></a>quantleft : forall n : nat, term n -&gt; term n.<br/>
&nbsp;&nbsp;intros n M.<br/>
&nbsp;&nbsp;case M.<br/>
&nbsp;&nbsp;exact var.<br/>
&nbsp;&nbsp;exact srt.<br/>
&nbsp;&nbsp;exact app.<br/>
&nbsp;&nbsp;intros.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;exact t.<br/>
&nbsp;&nbsp;intros.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;exact t.<br/>
<code class="keyword">Defined</code>.<br/>

<br/>
<code class="keyword">Implicit</code> Arguments quantleft [n].<br/>

<br/>
<code class="keyword">Definition</code> <a name="quantright"></a>quantright : forall n : nat, term n -&gt; term (S n).<br/>
&nbsp;&nbsp;intros n M.<br/>
&nbsp;&nbsp;case M.<br/>
&nbsp;&nbsp;intros.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;exact bot.<br/>
&nbsp;&nbsp;intros.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;exact bot.<br/>
&nbsp;&nbsp;intros. <br/>
&nbsp;&nbsp;&nbsp;&nbsp;exact bot.<br/>
&nbsp;&nbsp;intros.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;exact t0.<br/>
&nbsp;&nbsp;intros.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;exact t0.<br/>
<code class="keyword">Defined</code>.<br/>

<br/>
<code class="keyword">Implicit</code> Arguments quantright [n].<br/>

<br/>
<code class="keyword">Lemma</code> <a name="app_wd"></a>app_wd : forall n : nat, forall M M' N N' : term n, M = M' -&gt; N = N' -&gt;<br/>
&nbsp;&nbsp;app M N = app M' N'.<br/>
&nbsp;&nbsp;intros.<br/>
&nbsp;&nbsp;rewrite H.<br/>
&nbsp;&nbsp;rewrite H0.<br/>
&nbsp;&nbsp;reflexivity.<br/>
<code class="keyword">Save</code>.<br/>

<br/>
<code class="keyword">Lemma</code> <a name="app_injl"></a>app_injl : forall n : nat, forall M M' N N' : term n, app M N = app M' N' -&gt; M = M'.<br/>
&nbsp;&nbsp;intros.<br/>
&nbsp;&nbsp;transitivity (appleft (app M N)).<br/>
&nbsp;&nbsp;reflexivity.<br/>
&nbsp;&nbsp;rewrite H.<br/>
&nbsp;&nbsp;reflexivity.<br/>
<code class="keyword">Save</code>.<br/>

<br/>
<code class="keyword">Lemma</code> <a name="app_injr"></a>app_injr : forall (n : nat) (M M' N N' : term n), app M N = app M' N' -&gt; N = N'.<br/>
&nbsp;&nbsp;intros.<br/>
&nbsp;&nbsp;transitivity (appright (app M N)).<br/>
&nbsp;&nbsp;reflexivity.<br/>
&nbsp;&nbsp;rewrite H.<br/>
&nbsp;&nbsp;reflexivity.<br/>
<code class="keyword">Save</code>.<br/>

<br/>
<code class="keyword">Lemma</code> <a name="pi_wd"></a>pi_wd : forall n : nat, forall A A' : term n, forall B B' : term (S n), A = A' -&gt; B = B' -&gt;<br/>
&nbsp;&nbsp;pi A B = pi A' B'.<br/>
&nbsp;&nbsp;intros.<br/>
&nbsp;&nbsp;rewrite H.<br/>
&nbsp;&nbsp;rewrite H0.<br/>
&nbsp;&nbsp;reflexivity.<br/>
<code class="keyword">Save</code>.<br/>

<br/>
<code class="keyword">Lemma</code> <a name="pi_injl"></a>pi_injl : forall (n : nat) (A A' : term n) (B B' : term (S n)), pi A B = pi A' B' -&gt; A = A'.<br/>
&nbsp;&nbsp;intros.<br/>
&nbsp;&nbsp;transitivity (quantleft (pi A B)).<br/>
&nbsp;&nbsp;reflexivity.<br/>
&nbsp;&nbsp;rewrite H.<br/>
&nbsp;&nbsp;reflexivity.<br/>
<code class="keyword">Save</code>.<br/>

<br/>
<code class="keyword">Lemma</code> <a name="pi_injr"></a>pi_injr : forall (n : nat) (A A' : term n) (B B' : term (S n)), pi A B = pi A' B' -&gt; B = B'.<br/>
&nbsp;&nbsp;intros.<br/>
&nbsp;&nbsp;transitivity (quantright (pi A B)).<br/>
&nbsp;&nbsp;reflexivity.<br/>
&nbsp;&nbsp;rewrite H.<br/>
&nbsp;&nbsp;reflexivity.<br/>
<code class="keyword">Save</code>.<br/>

<br/>
<code class="keyword">Lemma</code> <a name="lda_wd"></a>lda_wd : forall n : nat, forall A A' : term n, forall M M' : term (S n), A = A' -&gt; M = M' -&gt;<br/>
&nbsp;&nbsp;lda A M = lda A' M'.<br/>
&nbsp;&nbsp;intros.<br/>
&nbsp;&nbsp;rewrite H.<br/>
&nbsp;&nbsp;rewrite H0.<br/>
&nbsp;&nbsp;reflexivity.<br/>
<code class="keyword">Save</code>.<br/>

<br/>
<code class="keyword">Lemma</code> <a name="lda_injl"></a>lda_injl : forall (n : nat) (A A' : term n) (M M' : term (S n)), lda A M = lda A' M' -&gt; A = A'.<br/>
&nbsp;&nbsp;intros.<br/>
&nbsp;&nbsp;transitivity (quantleft (lda A M)).<br/>
&nbsp;&nbsp;reflexivity.<br/>
&nbsp;&nbsp;rewrite H.<br/>
&nbsp;&nbsp;reflexivity.<br/>
<code class="keyword">Save</code>.<br/>

<br/>
<code class="keyword">Lemma</code> <a name="lda_injr"></a>lda_injr : forall (n : nat) (A A' : term n) (M M' : term (S n)), lda A M = lda A' M' -&gt; M = M'.<br/>
&nbsp;&nbsp;intros.<br/>
&nbsp;&nbsp;transitivity (quantright (lda A M)).<br/>
&nbsp;&nbsp;reflexivity.<br/>
&nbsp;&nbsp;rewrite H.<br/>
&nbsp;&nbsp;reflexivity.<br/>
<code class="keyword">Save</code>.<br/>

<br/>
<code class="keyword">Definition</code> <a name="subvar"></a>subvar : forall m : nat, term m -&gt; forall n : nat, (fin m -&gt; fin n) -&gt; term n.<br/>
&nbsp;&nbsp;induction 1.<br/>
&nbsp;&nbsp;intros m rho.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;exact (rho f).<br/>
&nbsp;&nbsp;intros m rho.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;exact (srt s).<br/>
&nbsp;&nbsp;intros m rho.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;exact (app (IHterm1 _ rho) (IHterm2 _ rho)).<br/>
&nbsp;&nbsp;intros m rho.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;exact (pi (IHterm1 _ rho) (IHterm2 _ (Sfun rho))).<br/>
&nbsp;&nbsp;intros m rho.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;exact (lda (IHterm1 _ rho) (IHterm2 _ (Sfun rho))).<br/>
<code class="keyword">Defined</code>.<br/>

<br/>
<code class="keyword">Implicit</code> Arguments subvar [m n].<br/>

<br/>
<code class="keyword">Lemma</code> <a name="subvar_ext"></a>subvar_ext : forall m : nat, forall M : term m, forall n :nat, forall rho sigma : fin m -&gt; fin n,<br/>
&nbsp;&nbsp;(forall x : fin m, rho x = sigma x) -&gt; subvar M rho = subvar M sigma.<br/>
&nbsp;&nbsp;induction M.<br/>
&nbsp;&nbsp;intros.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;simpl.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;rewrite H.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;reflexivity.<br/>
&nbsp;&nbsp;simpl.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;reflexivity.<br/>
&nbsp;&nbsp;simpl.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;intros.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;apply app_wd.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;apply IHM1.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assumption.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;apply IHM2.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assumption.<br/>
&nbsp;&nbsp;simpl.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;intros.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;apply pi_wd.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;apply IHM1.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assumption.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;apply IHM2.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;intro x.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case x.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;simpl.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;intro y.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rewrite H.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reflexivity.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;reflexivity.<br/>
&nbsp;&nbsp;simpl.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;intros.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;apply lda_wd.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;apply IHM1.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assumption.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;apply IHM2.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;intro x.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case x.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;simpl.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;intro y.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rewrite H.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reflexivity.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;reflexivity.<br/>
<code class="keyword">Save</code>.<br/>

<br/>
<code class="keyword">Lemma</code> <a name="subvar_lm"></a>subvar_lm : forall m : nat, forall M : term m, forall n p : nat, forall rho : fin m -&gt; fin n, forall sigma : fin n -&gt; fin p,<br/>
&nbsp;&nbsp;subvar (subvar M rho) sigma = subvar M (fun x : fin m =&gt; sigma (rho x)).<br/>
&nbsp;&nbsp;induction M.<br/>
&nbsp;&nbsp;simpl.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;reflexivity.<br/>
&nbsp;&nbsp;simpl.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;reflexivity.<br/>
&nbsp;&nbsp;simpl.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;intros.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;rewrite IHM1.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;rewrite IHM2.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;reflexivity.<br/>
&nbsp;&nbsp;simpl.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;intros.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;apply pi_wd. <br/>
&nbsp;&nbsp;&nbsp;&nbsp;apply IHM1. <br/>
&nbsp;&nbsp;&nbsp;&nbsp;rewrite IHM2.  <br/>
&nbsp;&nbsp;&nbsp;&nbsp;apply subvar_ext.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;intro x.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case x.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;reflexivity.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;reflexivity.<br/>
&nbsp;&nbsp;simpl.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;intros.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;apply lda_wd. <br/>
&nbsp;&nbsp;&nbsp;&nbsp;apply IHM1. <br/>
&nbsp;&nbsp;&nbsp;&nbsp;rewrite IHM2.  <br/>
&nbsp;&nbsp;&nbsp;&nbsp;apply subvar_ext.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;intro x.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case x.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;reflexivity.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;reflexivity.    <br/>
<code class="keyword">Save</code>.<br/>

<br/>
<code class="keyword">Lemma</code> <a name="triv_subvar"></a>triv_subvar : forall n : nat, forall M : term n,<br/>
&nbsp;&nbsp;subvar M (fun x : fin n =&gt; x) = M.<br/>
&nbsp;&nbsp;induction M; simpl; try reflexivity.<br/>
&nbsp;&nbsp;rewrite IHM1.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;rewrite IHM2.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;reflexivity. <br/>
&nbsp;&nbsp;apply pi_wd.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assumption.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;transitivity (subvar M2 (fun x : fin (S n) =&gt; x)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;apply subvar_ext.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;intro x.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unfold Sfun.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unfold liftfun.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case x; reflexivity.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assumption.<br/>
&nbsp;&nbsp;apply lda_wd.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assumption.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;transitivity (subvar M2 (fun x : fin (S n) =&gt; x)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;apply subvar_ext.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;intro x; case x; reflexivity.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assumption.<br/>
<code class="keyword">Save</code>. <br/>
&nbsp;&nbsp;<br/>
<code class="keyword">Definition</code> <a name="liftterm"></a>liftterm (n : nat) (M : term n) : term (S n) :=<br/>
&nbsp;&nbsp;subvar M (up (n:=n)).<br/>

<br/>
<code class="keyword">Implicit</code> Arguments liftterm [n].<br/>

<br/>
<code class="keyword">Lemma</code> <a name="liftterm_sort"></a>liftterm_sort : forall (n : nat) (M : term n) (s : sort),<br/>
&nbsp;&nbsp;liftterm M = srt s -&gt; M = srt s.<br/>
&nbsp;&nbsp;intros n M.<br/>
&nbsp;&nbsp;case M; try discriminate 1.<br/>
&nbsp;&nbsp;injection 1.<br/>
&nbsp;&nbsp;apply f_equal.<br/>
<code class="keyword">Save</code>.<br/>

<br/>
<code class="keyword">Lemma</code> <a name="subvar_liftterm"></a>subvar_liftterm : forall m n : nat, forall M : term m, forall rho : fin m -&gt; fin n,<br/>
&nbsp;&nbsp;liftterm (subvar M rho) = subvar (liftterm M) (Sfun rho).<br/>
&nbsp;&nbsp;unfold liftterm.<br/>
&nbsp;&nbsp;intros.<br/>
&nbsp;&nbsp;rewrite subvar_lm.<br/>
&nbsp;&nbsp;rewrite subvar_lm.<br/>
&nbsp;&nbsp;unfold Sfun.<br/>
&nbsp;&nbsp;unfold liftfun.<br/>
&nbsp;&nbsp;simpl.<br/>
&nbsp;&nbsp;reflexivity.<br/>
<code class="keyword">Save</code>.<br/>
&nbsp;&nbsp;<br/>
<code class="keyword">Definition</code> <a name="liftsub"></a>liftsub (m n : nat) (rho : fin m -&gt; term n) (x : fin (S m)) : term (S n) :=<br/>
&nbsp;&nbsp;match x with<br/>
&nbsp;&nbsp;| None =&gt; bot<br/>
&nbsp;&nbsp;| Some x0 =&gt; liftterm (rho x0)<br/>
&nbsp;&nbsp;end.<br/>

<br/>
<code class="keyword">Implicit</code> Arguments liftsub [m n].<br/>

<br/>
<code class="keyword">Definition</code> <a name="subst"></a>subst : forall m : nat, term m -&gt; forall n : nat, (fin m -&gt; term n) -&gt; term n.<br/>
&nbsp;&nbsp;induction 1.<br/>
&nbsp;&nbsp;intros m rho.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;exact (rho f).<br/>
&nbsp;&nbsp;intros m rho.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;exact (srt s).<br/>
&nbsp;&nbsp;intros m rho.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;exact (app (IHterm1 _ rho) (IHterm2 _ rho)).<br/>
&nbsp;&nbsp;intros m rho.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;exact (pi (IHterm1 _ rho) (IHterm2 _ (liftsub rho))).<br/>
&nbsp;&nbsp;intros m rho.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;exact (lda (IHterm1 _ rho) (IHterm2 _ (liftsub rho))).<br/>
<code class="keyword">Defined</code>.<br/>

<br/>
<code class="keyword">Implicit</code> Arguments subst [m n].<br/>

<br/>
<code class="keyword">Lemma</code> <a name="subst_ext"></a>subst_ext : forall m : nat, forall M : term m, forall n : nat, forall rho sigma : fin m -&gt; term n,<br/>
&nbsp;&nbsp;(forall x : fin m, rho x = sigma x) -&gt; subst M rho = subst M sigma.<br/>
&nbsp;&nbsp;induction M.<br/>
&nbsp;&nbsp;simpl.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;auto.<br/>
&nbsp;&nbsp;simpl.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;reflexivity.<br/>
&nbsp;&nbsp;simpl.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;intros.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;apply app_wd. <br/>
&nbsp;&nbsp;&nbsp;&nbsp;apply IHM1. <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assumption. <br/>
&nbsp;&nbsp;&nbsp;&nbsp;apply IHM2. <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assumption.<br/>
&nbsp;&nbsp;simpl.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;intros.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;apply pi_wd.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;apply IHM1.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assumption.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;apply IHM2.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;intro x.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case x.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;intro y.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;simpl.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rewrite H.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reflexivity.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;simpl.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reflexivity.<br/>
&nbsp;&nbsp;simpl.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;intros.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;apply lda_wd.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;apply IHM1.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assumption.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;apply IHM2.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;intro x.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case x.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;intro y.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;simpl.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rewrite H.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reflexivity.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;simpl.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reflexivity.<br/>
<code class="keyword">Save</code>.<br/>

<br/>
<code class="keyword">Lemma</code> <a name="subvar_subst"></a>subvar_subst : forall m : nat, forall M : term m, forall n p : nat,<br/>
&nbsp;&nbsp;forall sigma : fin m -&gt; fin n, forall rho : fin n -&gt; term p,<br/>
&nbsp;&nbsp;subst (subvar M sigma) rho = subst M (fun x : fin m =&gt; rho (sigma x)).<br/>
&nbsp;&nbsp;induction M.<br/>
&nbsp;&nbsp;simpl.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;reflexivity.<br/>
&nbsp;&nbsp;simpl.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;reflexivity. <br/>
&nbsp;&nbsp;simpl. <br/>
&nbsp;&nbsp;&nbsp;&nbsp;intros. <br/>
&nbsp;&nbsp;&nbsp;&nbsp;rewrite IHM1.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;rewrite IHM2.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;reflexivity.<br/>
&nbsp;&nbsp;simpl.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;intros.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;rewrite IHM1.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;rewrite IHM2.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;simpl.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;apply pi_wd.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;reflexivity.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;apply subst_ext.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;intro x.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case x.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;intro y.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;simpl.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reflexivity.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;simpl.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reflexivity.<br/>
&nbsp;&nbsp;simpl.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;intros.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;rewrite IHM1.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;rewrite IHM2.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;simpl.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;apply lda_wd.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;reflexivity.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;apply subst_ext.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;intro x.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case x.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;intro y.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;simpl.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reflexivity.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;simpl.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reflexivity.<br/>
<code class="keyword">Save</code>.<br/>

<br/>
<code class="keyword">Lemma</code> <a name="subst_subvar"></a>subst_subvar : forall m : nat, forall M : term m, forall n p : nat, forall rho : fin m -&gt; term n, forall sigma : fin n -&gt; fin p,<br/>
&nbsp;&nbsp;subvar (subst M rho) sigma = (subst M (fun x : fin m =&gt; subvar (rho x) sigma)).<br/>
&nbsp;&nbsp;induction M.<br/>
&nbsp;&nbsp;simpl.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;reflexivity.<br/>
&nbsp;&nbsp;reflexivity.<br/>
&nbsp;&nbsp;intros.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;simpl.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;apply app_wd.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;apply IHM1.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;apply IHM2.<br/>
&nbsp;&nbsp;intros.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;simpl.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;apply pi_wd.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;apply IHM1.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;rewrite IHM2.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;apply subst_ext.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;intro x.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case x.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;simpl.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;intro y.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;symmetry.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;apply subvar_liftterm.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;simpl.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reflexivity.<br/>
&nbsp;&nbsp;intros.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;simpl.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;apply lda_wd.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;apply IHM1.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;rewrite IHM2.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;apply subst_ext.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;intro x.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case x.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;simpl.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;intro y.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;symmetry.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;apply subvar_liftterm.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;simpl.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reflexivity.<br/>
<code class="keyword">Save</code>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
<code class="keyword">Lemma</code> <a name="liftterm_subst"></a>liftterm_subst : forall m : nat, forall M : term m, forall n : nat, forall rho : fin (S m) -&gt; term n,<br/>
&nbsp;&nbsp;subst (liftterm M) rho = subst M (fun x : fin m =&gt; rho (up x)).<br/>
&nbsp;&nbsp;intros.<br/>
&nbsp;&nbsp;unfold liftterm.<br/>
&nbsp;&nbsp;apply subvar_subst.<br/>
<code class="keyword">Save</code>.<br/>

<br/>
<code class="keyword">Lemma</code> <a name="subst_liftterm"></a>subst_liftterm : forall m : nat, forall M : term m, forall n : nat, forall rho : fin m -&gt; term n,<br/>
&nbsp;&nbsp;liftterm (subst M rho) = subst M (fun x : fin m =&gt; liftterm (rho x)).<br/>
&nbsp;&nbsp;unfold liftterm.<br/>
&nbsp;&nbsp;intros.<br/>
&nbsp;&nbsp;apply subst_subvar.<br/>
<code class="keyword">Save</code>.<br/>

<br/>
<code class="keyword">Lemma</code> <a name="subst_lm"></a>subst_lm : forall m : nat, forall M : term m, forall n p : nat, forall sigma : fin m -&gt; term n, forall rho : fin n -&gt; term p,<br/>
&nbsp;&nbsp;subst (subst M sigma) rho = subst M (fun x : fin m =&gt; subst (sigma x) rho).<br/>
&nbsp;&nbsp;induction M.<br/>
&nbsp;&nbsp;simpl.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;reflexivity.<br/>
&nbsp;&nbsp;simpl.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;reflexivity.<br/>
&nbsp;&nbsp;simpl.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;intros.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;rewrite IHM1.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;rewrite IHM2.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;reflexivity.<br/>
&nbsp;&nbsp;simpl.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;intros.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;apply pi_wd.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;apply IHM1.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;rewrite IHM2.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;apply subst_ext.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;intro x.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case x.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;intro y.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;simpl.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rewrite subst_liftterm. <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rewrite liftterm_subst. <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reflexivity.    <br/>
&nbsp;&nbsp;&nbsp;&nbsp;simpl.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reflexivity.<br/>
&nbsp;&nbsp;simpl.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;intros.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;apply lda_wd.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;apply IHM1.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;rewrite IHM2.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;apply subst_ext.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;intro x.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case x.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;intro y.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;simpl.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rewrite subst_liftterm. <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rewrite liftterm_subst. <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reflexivity.    <br/>
&nbsp;&nbsp;&nbsp;&nbsp;simpl.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reflexivity.<br/>
<code class="keyword">Save</code>.<br/>

<br/>
<code class="keyword">Lemma</code> <a name="triv_subst"></a>triv_subst : forall (n : nat) (M : term n), subst M (fun x : fin n =&gt; x) = M.<br/>
&nbsp;&nbsp;induction M; simpl; try reflexivity.<br/>
&nbsp;&nbsp;rewrite IHM1; rewrite IHM2; reflexivity.<br/>
&nbsp;&nbsp;apply pi_wd.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assumption.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;unfold liftsub.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;transitivity (subst M2 (fun x : fin (S n) =&gt; x)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;apply subst_ext.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;intro x; case x; reflexivity.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assumption.<br/>
&nbsp;&nbsp;apply lda_wd.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assumption.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;transitivity (subst M2 (fun x : fin (S n) =&gt; x)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;apply subst_ext.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;intro x; case x; reflexivity.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assumption.<br/>
<code class="keyword">Save</code>.<br/>

<br/>
<code class="keyword">Definition</code> <a name="subbot"></a>subbot (n : nat) (M : term (S n)) (N : term n) : term n :=<br/>
&nbsp;&nbsp;subst M<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(fun x : fin (S n) =&gt; match x with<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| None =&gt; N<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| Some x0 =&gt; var x0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;end).<br/>

<br/>
<code class="keyword">Implicit</code> Arguments subbot [n].<br/>

<br/>
<code class="keyword">Lemma</code> <a name="subbot_subst"></a>subbot_subst : forall (m n : nat) (M : term (S n)) (N : term n) (rho : fin n -&gt; term m),<br/>
&nbsp;&nbsp;subst (subbot M N) rho = subbot (subst M (liftsub rho)) (subst N rho).<br/>
&nbsp;&nbsp;intros.<br/>
&nbsp;&nbsp;unfold subbot.<br/>
&nbsp;&nbsp;rewrite subst_lm.<br/>
&nbsp;&nbsp;rewrite subst_lm.<br/>
&nbsp;&nbsp;apply subst_ext.<br/>
&nbsp;&nbsp;intro x.<br/>
&nbsp;&nbsp;case x.<br/>
&nbsp;&nbsp;simpl.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;intro y.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;unfold liftterm.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;rewrite subvar_subst.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;simpl.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;symmetry; apply triv_subst.<br/>
&nbsp;&nbsp;simpl.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;reflexivity.<br/>
<code class="keyword">Save</code>.<br/>

<br/>
<code class="keyword">Inductive</code> <a name="par_red1"></a>par_red1 : forall n : nat, term n -&gt; term n -&gt; Prop :=<br/>
&nbsp;&nbsp;<a name="par_red1_var"></a>par_red1_var : forall n : nat, forall x : fin n, par_red1 _ x x |<br/>
&nbsp;&nbsp;<a name="par_red1_srt"></a>par_red1_srt : forall n : nat, forall s : sort, par_red1 n (srt s) (srt s) |<br/>
&nbsp;&nbsp;<a name="par_red1_app"></a>par_red1_app : forall n : nat, forall M M' N N' : term n,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;par_red1 _ M M' -&gt; par_red1 _ N N' -&gt; par_red1 _ (app M N) (app M' N') |<br/>
&nbsp;&nbsp;<a name="par_red1_pi"></a>par_red1_pi : forall n : nat, forall A A' : term n, forall B B' : term (S n),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;par_red1 _ A A' -&gt; par_red1 _ B B' -&gt; par_red1 _ (pi A B) (pi A' B') |<br/>
&nbsp;&nbsp;<a name="par_red1_lda"></a>par_red1_lda : forall n : nat, forall A A' : term n, forall M M' : term (S n),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;par_red1 _ A A' -&gt; par_red1 _ M M' -&gt; par_red1 _ (lda A M) (lda A' M') |<br/>
&nbsp;&nbsp;<a name="par_red1_beta"></a>par_red1_beta : forall n : nat, forall M M' : term (S n), forall A N N' : term n,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;par_red1 _ M M' -&gt; par_red1 _ N N' -&gt; par_red1 _ (app (lda A M) N) (subbot M' N').<br/>

<br/>
<code class="keyword">Implicit</code> Arguments par_red1 [n].<br/>

<br/>
<code class="keyword">Lemma</code> <a name="pre_Gen_par_red1_var"></a>pre_Gen_par_red1_var : forall n : nat, forall M N : term n,<br/>
&nbsp;&nbsp;par_red1 M N -&gt; forall x : fin n, M = x -&gt; N = x.<br/>
&nbsp;&nbsp;induction 1; try discriminate 1.<br/>
&nbsp;&nbsp;auto.<br/>
<code class="keyword">Save</code>.<br/>

<br/>
<code class="keyword">Lemma</code> <a name="Gen_par_red1_var"></a>Gen_par_red1_var : forall n : nat, forall x : fin n, forall N : term n,<br/>
&nbsp;&nbsp;par_red1 x N -&gt; N = x.<br/>
&nbsp;&nbsp;intros.<br/>
&nbsp;&nbsp;apply pre_Gen_par_red1_var with (var x); auto.<br/>
<code class="keyword">Save</code>.<br/>

<br/>
<code class="keyword">Lemma</code> <a name="pre_Gen_par_red1_srt"></a>pre_Gen_par_red1_srt : forall n : nat, forall M N : term n,<br/>
&nbsp;&nbsp;par_red1 M N -&gt; forall s : sort, M = srt s -&gt; N = srt s.<br/>
&nbsp;&nbsp;induction 1; try discriminate 1.<br/>
&nbsp;&nbsp;tauto.<br/>
<code class="keyword">Save</code>.<br/>

<br/>
<code class="keyword">Lemma</code> <a name="Gen_par_red1_srt"></a>Gen_par_red1_srt : forall n : nat, forall s : sort, forall N : term n,<br/>
&nbsp;&nbsp;par_red1 (srt s) N -&gt; N = srt s.<br/>
&nbsp;&nbsp;intros.<br/>
&nbsp;&nbsp;apply pre_Gen_par_red1_srt with (srt (n:= n) s); auto.<br/>
<code class="keyword">Save</code>.<br/>

<br/>
<code class="keyword">Lemma</code> <a name="pre_Gen_par_red1_app"></a>pre_Gen_par_red1_app : forall n : nat, forall M N : term n, par_red1 M N -&gt;<br/>
&nbsp;&nbsp;forall P Q : term n, M = app P Q -&gt;<br/>
&nbsp;&nbsp;(exists P' : term n, exists Q' : term n, par_red1 P P' /\ par_red1 Q Q' /\ N = app P' Q') \/<br/>
&nbsp;&nbsp;(exists A : term n, exists Q' : term n, exists R : term (S n), exists R' : term (S n), P = lda A R /\ par_red1 Q Q' /\ par_red1 R R' /\ N = subbot R' Q').<br/>
&nbsp;&nbsp;induction 1; try discriminate 1.<br/>
&nbsp;&nbsp;injection 1.<br/>
&nbsp;&nbsp;left.<br/>
&nbsp;&nbsp;split with M'.<br/>
&nbsp;&nbsp;split with N'.<br/>
&nbsp;&nbsp;split.<br/>
&nbsp;&nbsp;replace P with M. <br/>
&nbsp;&nbsp;&nbsp;&nbsp;assumption. <br/>
&nbsp;&nbsp;&nbsp;&nbsp;transitivity (projS2 (existS (fun n : nat =&gt; term n) n M)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;reflexivity.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;transitivity (projS2 (existS (fun n : nat =&gt; term n) n P)).<br/>

<br/>
<code class="keyword">Lemma</code> <a name="par_red1_ref"></a>par_red1_ref : forall n : nat, forall M : term n, par_red1 M M.<br/>
&nbsp;&nbsp;induction M.<br/>
&nbsp;&nbsp;apply par_red1_var.<br/>
&nbsp;&nbsp;apply par_red1_srt.<br/>
&nbsp;&nbsp;apply par_red1_app; assumption.<br/>
&nbsp;&nbsp;apply par_red1_pi; assumption.<br/>
&nbsp;&nbsp;apply par_red1_lda; assumption.<br/>
<code class="keyword">Save</code>.<br/>

<br/>
<code class="keyword">Lemma</code> <a name="par_red1_subst"></a>par_red1_subst : forall n : nat, forall M N : term n, par_red1 M N -&gt;<br/>
&nbsp;&nbsp;forall m : nat, forall rho : fin n -&gt; term m,<br/>
&nbsp;&nbsp;par_red1 (subst M rho) (subst N rho).<br/>
&nbsp;&nbsp;induction 1; simpl.<br/>
&nbsp;&nbsp;intros; apply par_red1_ref.<br/>
&nbsp;&nbsp;intros; apply par_red1_srt.<br/>
&nbsp;&nbsp;intros; apply par_red1_app.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;apply IHpar_red1_1.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;apply IHpar_red1_2.<br/>
&nbsp;&nbsp;intros; apply par_red1_pi. <br/>
&nbsp;&nbsp;&nbsp;&nbsp;apply IHpar_red1_1. <br/>
&nbsp;&nbsp;&nbsp;&nbsp;apply IHpar_red1_2.<br/>
&nbsp;&nbsp;intros; apply par_red1_lda.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;apply IHpar_red1_1.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;apply IHpar_red1_2.<br/>
&nbsp;&nbsp;intros.  rewrite subbot_subst.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;apply par_red1_beta.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;apply IHpar_red1_1.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;apply IHpar_red1_2.<br/>
<code class="keyword">Save</code>.<br/>

<br/>
<code class="keyword">Inductive</code> <a name="red"></a>red (n : nat) : term n -&gt; term n -&gt; Prop :=<br/>
&nbsp;&nbsp;<a name="red_par_red1"></a>red_par_red1 : forall M N : term n, par_red1 M N -&gt; red _ M N |<br/>
&nbsp;&nbsp;<a name="red_trans"></a>red_trans : forall M N P : term n, red _ M N -&gt; red _ N P -&gt; red _ M P.<br/>

<br/>
<code class="keyword">Implicit</code> Arguments red [n].<br/>

<br/>
<code class="keyword">Lemma</code> <a name="red_subst"></a>red_subst : forall (n : nat) (M N : term n), red M N -&gt;<br/>
&nbsp;&nbsp;forall (m : nat) (rho : fin n -&gt; term m),<br/>
&nbsp;&nbsp;red (subst M rho) (subst N rho).<br/>
&nbsp;&nbsp;induction 1; intros.<br/>
&nbsp;&nbsp;apply red_par_red1.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;apply par_red1_subst.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assumption.<br/>
&nbsp;&nbsp;apply red_trans with (subst N rho).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;apply IHred1.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;apply IHred2.<br/>
<code class="keyword">Save</code>.<br/>

<br/>
<code class="keyword">Inductive</code> <a name="conv"></a>conv (n : nat) : term n -&gt; term n -&gt; Prop :=<br/>
&nbsp;&nbsp;<a name="conv_par_red1"></a>conv_par_red1 : forall M N : term n, par_red1 M N -&gt; conv _ M N |<br/>
&nbsp;&nbsp;<a name="conv_sym"></a>conv_sym : forall M N : term n, conv _ M N -&gt; conv _ N M |<br/>
&nbsp;&nbsp;<a name="conv_trans"></a>conv_trans : forall M N P : term n, conv _ M N -&gt; conv _ N P -&gt; conv _ M P.<br/>

<br/>
<code class="keyword">Implicit</code> Arguments conv [n].<br/>

<br/>
<code class="keyword">Lemma</code> <a name="conv_subst"></a>conv_subst : forall (n : nat) (M N : term n), conv M N -&gt;<br/>
&nbsp;&nbsp;forall (m : nat) (rho : fin n -&gt; term m),<br/>
&nbsp;&nbsp;conv (subst M rho) (subst N rho).<br/>
&nbsp;&nbsp;induction 1; intros.<br/>
&nbsp;&nbsp;apply conv_par_red1.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;apply par_red1_subst.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assumption.<br/>
&nbsp;&nbsp;apply conv_sym.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;apply IHconv.<br/>
&nbsp;&nbsp;apply conv_trans with (subst N rho).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;apply IHconv1.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;apply IHconv2.<br/>
<code class="keyword">Save</code>.<br/>

<br/>
<code class="keyword">Lemma</code> <a name="par_red1_dmnd"></a>par_red1_dmnd : forall n : nat, forall M N : term n, par_red1 M N -&gt;<br/>
&nbsp;&nbsp;forall P : term n, par_red1 M P -&gt; exists Q : term n,<br/>
&nbsp;&nbsp;par_red1 N Q /\ par_red1 P Q.<br/>
&nbsp;&nbsp;induction 1.<br/>
&nbsp;&nbsp;split with (var x).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;split.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;apply par_red1_var.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;rewrite Gen_par_red1_var with n x P.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;apply par_red1_var.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assumption.<br/>
&nbsp;&nbsp;split with (srt (n:= n) s).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;split.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;apply par_red1_srt.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;rewrite Gen_par_red1_srt with n s P.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;apply par_red1_srt.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assumption.<br/>
&nbsp;&nbsp;<br/>

<br/>
<code class="keyword">Fixpoint</code> <a name="context"></a>context (n : nat) {struct n} : Set :=<br/>
&nbsp;&nbsp;match n with<br/>
&nbsp;&nbsp;| O =&gt; unit<br/>
&nbsp;&nbsp;| (S m) =&gt; prod (context m) (term m)<br/>
&nbsp;&nbsp;end.<br/>

<br/>
<code class="keyword">Definition</code> <a name="typeof"></a>typeof : forall n : nat, fin n -&gt; context n -&gt; term n.<br/>
&nbsp;&nbsp;induction n.<br/>
&nbsp;&nbsp;intro x.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case x.<br/>
&nbsp;&nbsp;intro x.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case x.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;intros y Gamma.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case Gamma. <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;intros Delta A.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exact (liftterm (IHn y Delta)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;intro Gamma.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case Gamma.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;intros Delta A.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exact (liftterm A).<br/>
<code class="keyword">Defined</code>.<br/>

<br/>
<code class="keyword">Implicit</code> Arguments typeof [n].<br/>

<br/>
<code class="keyword">Parameter</code> <a name="axiom"></a>axiom : sort -&gt; sort -&gt; Prop.<br/>
<code class="keyword">Parameter</code> <a name="rule"></a>rule : sort -&gt; sort -&gt; sort -&gt; Prop.<br/>

<br/>
<code class="keyword">Inductive</code> <a name="PTS"></a>PTS : forall n : nat, context n -&gt; term n -&gt; term n -&gt; Prop :=<br/>
&nbsp;&nbsp;<a name="axioms"></a>axioms : forall s t : sort, axiom s t -&gt; PTS O tt (srt s) (srt t) |<br/>
&nbsp;&nbsp;<a name="start"></a>start : forall n : nat, forall Gamma : context n, forall A : term n, forall s : sort,<br/>
&nbsp;&nbsp;&nbsp;PTS _ Gamma A (srt s) -&gt; PTS (S n) (Gamma, A) bot (liftterm A) |<br/>
&nbsp;&nbsp;<a name="weakening"></a>weakening : forall n : nat, forall Gamma : context n, forall A B C : term n, forall s : sort,<br/>
&nbsp;&nbsp;&nbsp;PTS _ Gamma A B -&gt; PTS _ Gamma C (srt s) -&gt; PTS (S n) (Gamma, C) (liftterm A) (liftterm B) |<br/>
&nbsp;&nbsp;<a name="product"></a>product : forall n : nat, forall Gamma : context n, forall A : term n, forall B : term (S n), forall s1 s2 s3 : sort,<br/>
&nbsp;&nbsp;&nbsp;rule s1 s2 s3 -&gt;<br/>
&nbsp;&nbsp;&nbsp;PTS _ Gamma A (srt s1) -&gt; PTS (S n) (Gamma, A) B (srt s2) -&gt; PTS _ Gamma (pi A B) (srt s3) |<br/>
&nbsp;&nbsp;<a name="application"></a>application : forall n : nat, forall Gamma : context n, forall F A a : term n, forall B : term (S n),<br/>
&nbsp;&nbsp;&nbsp;PTS _ Gamma F (pi A B) -&gt; PTS _ Gamma a A -&gt; PTS _ Gamma (app F a) (subbot B a) |<br/>
&nbsp;&nbsp;<a name="abstraction"></a>abstraction : forall n : nat, forall Gamma : context n, forall A : term n, forall b B : term (S n), forall s1 s2 s3 : sort,<br/>
&nbsp;&nbsp;&nbsp;rule s1 s2 s3 -&gt;<br/>
&nbsp;&nbsp;&nbsp;PTS (S n) (Gamma, A) b B -&gt; PTS _ Gamma A (srt s1) -&gt; PTS (S n) (Gamma, A) B (srt s2) -&gt; PTS _ Gamma (lda A b) (pi A B) |<br/>
&nbsp;&nbsp;<a name="conversion"></a>conversion : forall n : nat, forall Gamma : context n, forall A B B' : term n, forall s : sort,<br/>
&nbsp;&nbsp;&nbsp;conv B B' -&gt;<br/>
&nbsp;&nbsp;&nbsp;PTS _ Gamma A B -&gt; PTS _ Gamma B' (srt s) -&gt; PTS _ Gamma A B'.<br/>

<br/>
<code class="keyword">Implicit</code> Arguments PTS [n].<br/>

<br/>
<code class="keyword">Definition</code> <a name="valid"></a>valid : forall n : nat, context n -&gt; Prop.<br/>
&nbsp;&nbsp;induction n.<br/>
&nbsp;&nbsp;intro.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;exact True.<br/>
&nbsp;&nbsp;intro Gamma.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case Gamma.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;intros Delta A.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;exact (IHn Delta /\ exists s : sort, PTS Delta A (srt s)).<br/>
<code class="keyword">Defined</code>.<br/>

<br/>
<code class="keyword">Implicit</code> Arguments valid [n].<br/>

<br/>
<code class="keyword">Lemma</code> <a name="Context_Validity"></a>Context_Validity : forall n : nat, forall Gamma : context n, forall M A : term n,<br/>
&nbsp;&nbsp;PTS Gamma M A -&gt; valid Gamma.<br/>
&nbsp;&nbsp;induction 1.<br/>
&nbsp;&nbsp;split.<br/>
&nbsp;&nbsp;split.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assumption.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;split with s.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assumption.<br/>
&nbsp;&nbsp;split.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assumption.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;split with s.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assumption.<br/>
&nbsp;&nbsp;assumption.<br/>
&nbsp;&nbsp;assumption.<br/>
&nbsp;&nbsp;assumption.<br/>
&nbsp;&nbsp;assumption.<br/>
<code class="keyword">Save</code>.<br/>

<br/>
<code class="keyword">Lemma</code> <a name="Start_ax"></a>Start_ax : forall n : nat, forall Gamma : context n, forall s t : sort,<br/>
&nbsp;&nbsp;axiom s t -&gt; valid Gamma -&gt; PTS Gamma (srt s) (srt t).<br/>
&nbsp;&nbsp;induction n.<br/>
&nbsp;&nbsp;induction Gamma.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;intros.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;apply axioms.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assumption.<br/>
&nbsp;&nbsp;induction Gamma.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;intros.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;elim H0.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;intros.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;elim H2.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;intros s' H3.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;apply weakening with (A:= (srt (n:= n) s)) (B:= (srt (n:= n) t)) (s:= s').<br/>
&nbsp;&nbsp;&nbsp;&nbsp;apply IHn.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assumption.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assumption.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assumption.<br/>
<code class="keyword">Save</code>.<br/>

<br/>
<code class="keyword">Lemma</code> <a name="Start_var"></a>Start_var : forall n : nat, forall Gamma : context n, forall x : fin n,<br/>
&nbsp;&nbsp;valid Gamma -&gt; PTS Gamma x (typeof x Gamma).<br/>
&nbsp;&nbsp;induction n.<br/>
&nbsp;&nbsp;intros Gamma x.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case x.<br/>
&nbsp;&nbsp;intro Gamma.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case Gamma.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;intros Delta A x.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case x.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;simpl.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;intros y H.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elim H.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;intros.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elim H1.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;intros s H2.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;apply weakening with (A:= (var y)) (s:= s).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;apply IHn.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assumption.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assumption.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;simpl.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;intros H.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elim H.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;intros.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elim H1.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;intros s H2.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;apply start with (n:= n) (s:= s).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assumption.<br/>
<code class="keyword">Save</code>.<br/>

<br/>
<code class="keyword">Definition</code> <a name="satisfy"></a>satisfy : forall n : nat, context n -&gt; forall m : nat, context m -&gt; (fin n -&gt; term m) -&gt; Prop.<br/>
&nbsp;&nbsp;induction n.<br/>
&nbsp;&nbsp;intros Delta m Gamma rho.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;exact (valid Gamma).<br/>
&nbsp;&nbsp;intro Delta.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case Delta.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;intros Delta0 A m Gamma rho.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;exact ((IHn Delta0 m Gamma (fun x : fin n =&gt; rho (up x))) /\<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(PTS Gamma (rho bot) (subst A (fun x : fin n =&gt; rho (up x))))).<br/>
<code class="keyword">Defined</code>.<br/>

<br/>
<code class="keyword">Implicit</code> Arguments satisfy [n m].<br/>

<br/>
<code class="keyword">Lemma</code> <a name="Weak_satisfy"></a>Weak_satisfy : forall n : nat, forall Delta : context n, forall m : nat, forall Gamma : context m, forall A : term m, forall rho : (fin n -&gt; term m), forall s : sort,<br/>
&nbsp;&nbsp;satisfy Delta Gamma rho -&gt; PTS Gamma A (srt s) -&gt;<br/>
&nbsp;&nbsp;satisfy Delta (m:= S m) (Gamma, A) (fun x : fin n =&gt; liftterm (rho x)).<br/>
&nbsp;&nbsp;induction n.<br/>
&nbsp;&nbsp;simpl.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;split.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assumption.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;split with s.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assumption.<br/>
&nbsp;&nbsp;intro Delta.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case Delta.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;fold context.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;intros Delta0 B.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;simpl.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;split.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;apply IHn with (rho:= fun x : fin n =&gt; rho (up x)) (s:= s).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elim H. <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tauto. <br/>
&nbsp;&nbsp;&nbsp;&nbsp;assumption. <br/>
&nbsp;&nbsp;&nbsp;&nbsp;rewrite &lt;- subst_liftterm with (rho:= fun x : fin n =&gt; rho (up x)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;apply weakening with s.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;elim H.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;tauto.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assumption.<br/>
<code class="keyword">Save</code>.<br/>

<br/>
<code class="keyword">Lemma</code> <a name="Substitution"></a>Substitution : forall n : nat, forall Delta : context n, forall M A : term n, <br/>
&nbsp;&nbsp;PTS Delta M A -&gt;<br/>
&nbsp;&nbsp;forall m : nat, forall Gamma : context m, forall rho : fin n -&gt; term m,<br/>
&nbsp;&nbsp;satisfy Delta Gamma rho -&gt; PTS Gamma (subst M rho) (subst A rho).<br/>
&nbsp;&nbsp;induction 1.<br/>
&nbsp;&nbsp;intros.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;simpl.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;apply Start_ax.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assumption.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assumption.<br/>
&nbsp;&nbsp;simpl.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;intros.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;rewrite liftterm_subst.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;elim H0.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;tauto.<br/>
&nbsp;&nbsp;simpl.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;intros. <br/>
&nbsp;&nbsp;&nbsp;&nbsp;rewrite liftterm_subst.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;rewrite liftterm_subst. <br/>
&nbsp;&nbsp;&nbsp;&nbsp;apply IHPTS1. <br/>
&nbsp;&nbsp;&nbsp;&nbsp;elim H1.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;tauto.<br/>
&nbsp;&nbsp;simpl.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;intros.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;apply product with s1 s2.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assumption.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;apply IHPTS1 with (rho:= rho).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assumption.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;apply IHPTS2 with (rho:= (liftsub rho)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;split.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unfold liftsub.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;simpl.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;apply Weak_satisfy with s1.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assumption.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;apply IHPTS1 with (rho:= rho).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assumption.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;simpl.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rewrite &lt;- subst_liftterm.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;apply start with s1.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;apply IHPTS1 with (rho:= rho).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assumption.<br/>
&nbsp;&nbsp;simpl.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;intros.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;rewrite subbot_subst.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;apply application with (subst A rho).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;apply IHPTS1 with (rho:= rho).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assumption.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;apply IHPTS2.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assumption.<br/>
&nbsp;&nbsp;simpl.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;intros.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;apply abstraction with s1 s2 s3.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assumption.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;apply IHPTS1.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;split.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;simpl.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;apply Weak_satisfy with s1.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assumption.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;apply IHPTS2 with (rho:= rho).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assumption.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;simpl.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rewrite &lt;- subst_liftterm.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;apply start with s1.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;apply IHPTS2 with (rho:= rho).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assumption.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;apply IHPTS2 with (rho:= rho).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assumption.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;apply IHPTS3 with (rho:= (liftsub rho)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;split; simpl.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;apply Weak_satisfy with s1.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assumption.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;apply IHPTS2 with (rho:= rho).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assumption.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;rewrite &lt;- subst_liftterm.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;apply start with s1.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;apply IHPTS2 with (rho:= rho).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assumption.<br/>
&nbsp;&nbsp;intros.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;apply conversion with (subst B rho) s.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;apply conv_subst.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assumption.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;apply IHPTS1. <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assumption. <br/>
&nbsp;&nbsp;&nbsp;&nbsp;apply IHPTS2 with (rho:= rho).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assumption.<br/>
<code class="keyword">Save</code>.<br/>

<br/>
<code class="keyword">Lemma</code> <a name="pre_Generation_sort"></a>pre_Generation_sort : forall n : nat, forall Gamma : context n, forall M C : term n,<br/>
&nbsp;&nbsp;PTS Gamma M C -&gt; forall c : sort, M = srt c -&gt; exists t : sort, C = srt t /\ axiom c t.<br/>
&nbsp;&nbsp;induction 1; try discriminate 1.<br/>
&nbsp;&nbsp;injection 1.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;split with t.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;rewrite &lt;- H1.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;auto.<br/>
&nbsp;&nbsp;intros.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;elim IHPTS1 with c.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;intros.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;split with x.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;elim H2.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;intros.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;rewrite H3.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;auto.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;apply liftterm_sort.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assumption.<br/>
&nbsp;&nbsp;<br/>

<br/>
<code class="keyword">Lemma</code> <a name="Gen_sort"></a>Gen_sort : forall n : nat, forall Gamma : context n, forall c : sort, forall C : term n,<br/>
&nbsp;&nbsp;PTS Gamma (srt c) C -&gt; exists t : sort, C = srt t /\ axiom c t.<br/>
&nbsp;&nbsp;induction 1.<br/>
&nbsp;&nbsp;split with t.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;split.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;reflexivity. <br/>
&nbsp;&nbsp;&nbsp;&nbsp;assumption. <br/>
</code>
<hr/><a href="index.html">Index</a><hr/><font size="-1">This page has been generated by <a href="http://www.lri.fr/~filliatr/coqdoc/">coqdoc</a></font>
</body>
</html>